## reactive和effect的实现细节

### 1、reactive模块的功能

```
普通对象 变为 响应式对象
```

### 2、effect模块的功能

```
1、响应式对象发生改变，就会执行effect的内容
2、明确它是一个函数执行（函数是用户给的）
```

#### 2.1 effect函数

```
1、将要执行的函数保存起来
```

#### 2.2 track函数

```
1、什么时候跟踪？
	访问响应式数据的时候
2、跟踪后干什么？
	应该保存用户传递的函数，便于之后的触发
```

#### 2.3 trigger函数

```
1、什么时候触发？
	响应式数据发生改变
2、触发后干什么？
	执行用户传递的函数
```

#### 2.4 注意事项

```
1、如何建立effect，track和trigger的联系？
	用全局变量存储用户传递的方法
2、用map存储数据（键值对唯一，且方便查找）
	数据格式：
	map = {
		target: {
			key: new Set()
		}
	}
3、最后一层为什么用set？
	避免重复添加方法
4、如何解决effect嵌套的问题？
	出现原因：主要是每次只保存一个函数，用完了置为undefined，没办法解决多层嵌套的问题
	解决办法：用一个effectSatck栈存储从外到里的方法，这样就能保证方法全部保存
```

### 3、computed模块

```
1、computed可以传递一个getter方法和一个对象（包含getter和setter）
2、计算属性只有当依赖得值发生更新才会执行计算，否则从缓存中取，怎么做？
	使用effect监听属性的变化，用_dirct变量存储值是否发生改变
	设置调度函数来解决effect首次监听的问题
```

